BROKER SCHEMA subflow
--CREATE COMPUTE MODULE ISO_FLOW_CANCEL_TIMER
--	CREATE FUNCTION Main() RETURNS BOOLEAN
--	BEGIN
--		SET OutputRoot = InputRoot;
--		SET OutputLocalEnvironment.variables.TimeoutRequest.Action = 'CANCEL';
--		IF InputRoot.XMLNSC.data.body.messageType = '0800' THEN
--			SET OutputLocalEnvironment.variables.TimeoutRequest.Identifier = CAST(InputRoot.XMLNSC.data.body.transmissionDateTime||InputRoot.XMLNSC.data.body.systemTraceAuditNumber AS CHARACTER CCSID 1208);
--		ELSE
--			SET OutputLocalEnvironment.variables.TimeoutRequest.Identifier = CAST(InputRoot.MQMD.CorrelId AS CHARACTER CCSID 1208);
--		END IF;
--		RETURN TRUE;
--	END;
--
--	CREATE PROCEDURE CopyMessageHeaders() BEGIN
--		DECLARE I INTEGER 1;
--		DECLARE J INTEGER;
--		SET J = CARDINALITY(InputRoot.*[]);
--		WHILE I < J DO
--			SET OutputRoot.*[I] = InputRoot.*[I];
--			SET I = I + 1;
--		END WHILE;
--	END;
--
--	CREATE PROCEDURE CopyEntireMessage() BEGIN
--		SET OutputRoot = InputRoot;
--	END;
--END MODULE;

CREATE COMPUTE MODULE ISO_FLOW_ROUTE
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;
		DECLARE msgType CHAR;
		SET msgType = InputRoot.XMLNSC.data.body.messageType;
		--DECLARE frontReqMsgType CHAR;
		--SET frontReqMsgType = InputRoot.XMLNSC.data.body.frontOriginal.body.messageType;
		
		IF STARTSWITH(msgType,'04') OR STARTSWITH(msgType,'022') THEN
			SET OutputRoot.MQMD.Expiry = -1;
			PROPAGATE TO TERMINAL 'out1';
		ELSEIF msgType = MsgNetReqType THEN
			PROPAGATE TO TERMINAL 'out3';
		ELSE
			PROPAGATE TO TERMINAL 'out2';
		END IF;
		RETURN TRUE;
	END;
	
	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;


--CREATE COMPUTE MODULE ISO_FLOW_SET_TIMEOUT
--	CREATE FUNCTION Main() RETURNS BOOLEAN
--	BEGIN
--		
--		SET OutputRoot = InputRoot;
--		
--		DELETE FIELD OutputLocalEnvironment.variables;
--		DELETE FIELD OutputRoot.XMLNSC.sql;
--		
--		DECLARE OutputTimestamp TIMESTAMP CURRENT_TIMESTAMP + CAST((delayTime) AS INTERVAL SECOND);
--		SET OutputLocalEnvironment.variables.TimeoutRequest.Action = 'SET';
--		SET OutputLocalEnvironment.variables.TimeoutRequest.Identifier = CAST(InputRoot.MQMD.CorrelId AS CHARACTER CCSID 1208);
--		SET OutputLocalEnvironment.variables.TimeoutRequest.StartDate = CAST(OutputTimestamp AS DATE);
--		SET OutputLocalEnvironment.variables.TimeoutRequest.StartTime = CAST(OutputTimestamp AS TIME);
--		SET OutputLocalEnvironment.variables.TimeoutRequest.IgnoreMissed = FALSE;
--		SET OutputLocalEnvironment.variables.TimeoutRequest.AllowOverwrite = FALSE;
--		SET OutputLocalEnvironment.variables.TimeoutRequest.Count = 1;
--		
----		SET OutputLocalEnvironment.variables.LOCAL = CAST(CURRENT_TIMESTAMP AS CHARACTER FORMAT 'yyyy-MM-dd hh:mm:ss');
----		SET OutputLocalEnvironment.variables.GMT = CAST(CURRENT_GMTTIMESTAMP AS CHARACTER FORMAT 'yyyy-MM-dd hh:mm:ss');
--		RETURN TRUE;
--	END;
--
--	CREATE PROCEDURE CopyMessageHeaders() BEGIN
--		DECLARE I INTEGER 1;
--		DECLARE J INTEGER;
--		SET J = CARDINALITY(InputRoot.*[]);
--		WHILE I < J DO
--			SET OutputRoot.*[I] = InputRoot.*[I];
--			SET I = I + 1;
--		END WHILE;
--	END;
--
--	CREATE PROCEDURE CopyEntireMessage() BEGIN
--		SET OutputRoot = InputRoot;
--	END;
--END MODULE;


--CREATE COMPUTE MODULE ISO_FLOW_CancelTimeoutAfterMagIn
--	CREATE FUNCTION Main() RETURNS BOOLEAN
--	BEGIN
--		SET OutputRoot = InputRoot;
--		SET OutputLocalEnvironment.copyOfResp = InputRoot.XMLNSC.data;
--		SET OutputLocalEnvironment.MQMD = InputRoot.MQMD;
--		RETURN TRUE;
--	END;
--
--	CREATE PROCEDURE CopyMessageHeaders() BEGIN
--		DECLARE I INTEGER 1;
--		DECLARE J INTEGER;
--		SET J = CARDINALITY(InputRoot.*[]);
--		WHILE I < J DO
--			SET OutputRoot.*[I] = InputRoot.*[I];
--			SET I = I + 1;
--		END WHILE;
--	END;
--END MODULE;


CREATE COMPUTE MODULE ISO_FLOW_SET_SUSPECT
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;
		SET OutputRoot.XMLNSC.data = InputRoot.XMLNSC.data.body.frontOriginal;
		SET OutputRoot.XMLNSC.data.body.responseCode = '68';
		SET OutputRoot.XMLNSC.data.mappingId = 'resp-sp.'||InputRoot.XMLNSC.data.body.frontOriginal.group;
		SET OutputRoot.MQMD.ReplyToQ = InputRoot.XMLNSC.data.ReplyToQ;
		SET OutputRoot.MQMD.ReplyToQMgr = '';
		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;


CREATE COMPUTE MODULE ISO_FLOW_SET_FAILED_LN
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;
		IF FIELDTYPE(InputRoot.XMLNSC.data.body.frontOriginal) IS NOT NULL THEN
			SET OutputRoot.XMLNSC.data = InputRoot.XMLNSC.data.body.frontOriginal;
			SET OutputRoot.XMLNSC.data.mappingId = 'resp-ln.'||InputRoot.XMLNSC.data.body.frontOriginal.group;
		ELSE
			SET OutputRoot.XMLNSC.data.mappingId = 'resp-ln.'||InputRoot.XMLNSC.data.group;
		END IF;
		
		IF STARTSWITH(OutputRoot.XMLNSC.data.body.messageType, '022') THEN
			SET OutputRoot.XMLNSC.data.body.messageType = '0230';
		ELSEIF STARTSWITH(OutputRoot.XMLNSC.data.body.messageType, '02') THEN
			SET OutputRoot.XMLNSC.data.body.messageType = '0210';
		ELSEIF STARTSWITH(OutputRoot.XMLNSC.data.body.messageType, '04') THEN
			SET OutputRoot.XMLNSC.data.body.messageType = '0410';
		ELSE
			SET OutputRoot.XMLNSC.data.body.messageType = '0810';
		END IF;
		SET OutputRoot.XMLNSC.data.body.{bit39} = respLinkDown;
		SET OutputRoot.MQMD.ReplyToQMgr = '';
		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;


--CREATE COMPUTE MODULE ISO_FLOW_VerifyMsg
--	CREATE FUNCTION Main() RETURNS BOOLEAN
--	BEGIN
--		--IF InputRoot.XMLNSC.data.flowType = 'P' OR InputRoot.XMLNSC.data.flowType = 'p' THEN
--			SET OutputRoot = InputRoot;
--			IF OutputRoot.XMLNSC.data.TimeOutCounter IS NULL THEN
--				SET OutputRoot.XMLNSC.data.TimeOutCounter = 0;
--			ELSE
--				SET OutputRoot.XMLNSC.data.TimeOutCounter = CAST (InputRoot.XMLNSC.data.TimeOutCounter AS INTEGER)+1;
--			END IF;
--			RETURN TRUE;
----		ELSE
----			SET OutputRoot = InputRoot;
----			PROPAGATE TO TERMINAL 'out2';
----		END IF;
--	END;
--
--	CREATE PROCEDURE CopyMessageHeaders() BEGIN
--		DECLARE I INTEGER 1;
--		DECLARE J INTEGER;
--		SET J = CARDINALITY(InputRoot.*[]);
--		WHILE I < J DO
--			SET OutputRoot.*[I] = InputRoot.*[I];
--			SET I = I + 1;
--		END WHILE;
--	END;
--
--	CREATE PROCEDURE CopyEntireMessage() BEGIN
--		SET OutputRoot = InputRoot;
--	END;
--END MODULE;


CREATE COMPUTE MODULE ISO_FLOW_SET_RESPONSE
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;
		-- Compose Message Reply ke Requestor
		IF InputRoot.XMLNSC.data.body.messageType = MsgFinRespType THEN
			SET OutputRoot.XMLNSC.data.body.messageType = MsgFinReqType;
		ELSEIF InputRoot.XMLNSC.data.body.messageType = MsgRevReqType THEN
			SET OutputRoot.XMLNSC.data.body.messageType = MsgRevRespType;
		END IF;

		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;



--CREATE COMPUTE MODULE ISO_FLOW_SET_TO
--	CREATE FUNCTION Main() RETURNS BOOLEAN
--	BEGIN
--		SET OutputRoot = InputRoot;
--		IF STARTSWITH(InputRoot.XMLNSC.data.body.messageType, '02') THEN
--			SET OutputRoot.XMLNSC.data.body.messageType = MsgFinRespType;
--		ELSEIF STARTSWITH(InputRoot.XMLNSC.data.body.messageType, '04') THEN
--			SET OutputRoot.XMLNSC.data.body.messageType = MsgRevRespType;
--		ELSE
--			SET OutputRoot.XMLNSC.data.body.messageType = MsgNetRespType;
--		END IF;
--		SET OutputRoot.XMLNSC.data.body.{bit39} = respTimeOut;
--		SET OutputRoot.XMLNSC.data.code = OutputRoot.XMLNSC.data.body.messageType ||'.'||InputRoot.XMLNSC.data.body.{bit3};
--		RETURN TRUE;
--	END;
--
--	CREATE PROCEDURE CopyMessageHeaders() BEGIN
--		DECLARE I INTEGER 1;
--		DECLARE J INTEGER;
--		SET J = CARDINALITY(InputRoot.*[]);
--		WHILE I < J DO
--			SET OutputRoot.*[I] = InputRoot.*[I];
--			SET I = I + 1;
--		END WHILE;
--	END;
--
--	CREATE PROCEDURE CopyEntireMessage() BEGIN
--		SET OutputRoot = InputRoot;
--	END;
--END MODULE;


--CREATE COMPUTE MODULE ISO_FLOW_Verify_Counter
--	CREATE FUNCTION Main() RETURNS BOOLEAN
--	BEGIN
--		CALL CopyMessageHeaders();
--		DECLARE counter INTEGER;
--
--		IF InputRoot.XMLNSC.data.TimeOutCounter IS NULL THEN
--			SET counter = 0;
--		ELSE
--			SET counter = CAST (InputRoot.XMLNSC.revCounter AS INTEGER);
--		END IF;
--
--		IF counter <= numReversalRetry THEN
--			SET OutputRoot.XMLNSC.revCounter = counter + 1;
--			PROPAGATE TO TERMINAL 'out1';
--		ELSE
--			PROPAGATE TO TERMINAL 'out2';
--		END IF;
--		RETURN FALSE;
--	END;
--
--	CREATE PROCEDURE CopyMessageHeaders() BEGIN
--		DECLARE I INTEGER 1;
--		DECLARE J INTEGER;
--		SET J = CARDINALITY(InputRoot.*[]);
--		WHILE I < J DO
--			SET OutputRoot.*[I] = InputRoot.*[I];
--			SET I = I + 1;
--		END WHILE;
--	END;
--
--	CREATE PROCEDURE CopyEntireMessage() BEGIN
--		SET OutputRoot = InputRoot;
--	END;
--END MODULE;

--CREATE COMPUTE MODULE ISO_FLOW_SetTimer
--	CREATE FUNCTION Main() RETURNS BOOLEAN
--	BEGIN
--		
--		SET OutputRoot = InputRoot;
--		RETURN TRUE;
--	END;
--
--	CREATE PROCEDURE CopyMessageHeaders() BEGIN
--		DECLARE I INTEGER 1;
--		DECLARE J INTEGER;
--		SET J = CARDINALITY(InputRoot.*[]);
--		WHILE I < J DO
--			SET OutputRoot.*[I] = InputRoot.*[I];
--			SET I = I + 1;
--		END WHILE;
--	END;
--
--	CREATE PROCEDURE CopyEntireMessage() BEGIN
--		SET OutputRoot = InputRoot;
--	END;
--END MODULE;


--CREATE COMPUTE MODULE ISO_FLOW_SetSid
--	CREATE FUNCTION Main() RETURNS BOOLEAN
--	BEGIN
--		-- CALL CopyMessageHeaders();
--		CALL CopyEntireMessage();
--		SET OutputRoot.XMLNSC.data.sid = CAST(InputRoot.MQMD.MsgId AS CHARACTER);
--		RETURN TRUE;
--	END;
--
--	CREATE PROCEDURE CopyMessageHeaders() BEGIN
--		DECLARE I INTEGER 1;
--		DECLARE J INTEGER;
--		SET J = CARDINALITY(InputRoot.*[]);
--		WHILE I < J DO
--			SET OutputRoot.*[I] = InputRoot.*[I];
--			SET I = I + 1;
--		END WHILE;
--	END;
--
--	CREATE PROCEDURE CopyEntireMessage() BEGIN
--		SET OutputRoot = InputRoot;
--	END;
--END MODULE;
--
--
--CREATE COMPUTE MODULE ISO_FLOW_SetParamInq
--	CREATE FUNCTION Main() RETURNS BOOLEAN
--	BEGIN
--		SET OutputRoot = InputRoot;
--		DELETE FIELD OutputLocalEnvironment.variables;
--		SET OutputRoot.XMLNSC.sql.mappingId = InputRoot.XMLNSC.data.body.{bit3}||'_'||InputRoot.XMLNSC.data.body.messageType;
--		RETURN TRUE;
--	END;
--
--	CREATE PROCEDURE CopyMessageHeaders() BEGIN
--		DECLARE I INTEGER 1;
--		DECLARE J INTEGER;
--		SET J = CARDINALITY(InputRoot.*[]);
--		WHILE I < J DO
--			SET OutputRoot.*[I] = InputRoot.*[I];
--			SET I = I + 1;
--		END WHILE;
--	END;
--
--	CREATE PROCEDURE CopyEntireMessage() BEGIN
--		SET OutputRoot = InputRoot;
--	END;
--END MODULE;
--
--CREATE COMPUTE MODULE ISO_FLOW_REMOVE_LOCALENV
--	CREATE FUNCTION Main() RETURNS BOOLEAN
--	BEGIN
--		SET OutputRoot = InputRoot;
--		DELETE FIELD OutputLocalEnvironment.variables;
--		RETURN TRUE;
--	END;
--
--	CREATE PROCEDURE CopyMessageHeaders() BEGIN
--		DECLARE I INTEGER 1;
--		DECLARE J INTEGER;
--		SET J = CARDINALITY(InputRoot.*[]);
--		WHILE I < J DO
--			SET OutputRoot.*[I] = InputRoot.*[I];
--			SET I = I + 1;
--		END WHILE;
--	END;
--
--	CREATE PROCEDURE CopyEntireMessage() BEGIN
--		SET OutputRoot = InputRoot;
--	END;
--END MODULE;

--CREATE COMPUTE MODULE NEW_ISO_FLOW_SET_PARAM
--	CREATE FUNCTION Main() RETURNS BOOLEAN
--	BEGIN
--		SET OutputRoot = InputRoot;
--		DELETE FIELD OutputLocalEnvironment.variables;
--		SET OutputRoot.XMLNSC.sql.mappingId = InputRoot.XMLNSC.data.body.{bit3}||'_'||InputRoot.XMLNSC.data.body.messageType;
--		RETURN TRUE;
--	END;
--
--	CREATE PROCEDURE CopyMessageHeaders() BEGIN
--		DECLARE I INTEGER 1;
--		DECLARE J INTEGER;
--		SET J = CARDINALITY(InputRoot.*[]);
--		WHILE I < J DO
--			SET OutputRoot.*[I] = InputRoot.*[I];
--			SET I = I + 1;
--		END WHILE;
--	END;
--
--	CREATE PROCEDURE CopyEntireMessage() BEGIN
--		SET OutputRoot = InputRoot;
--	END;
--END MODULE;

CREATE COMPUTE MODULE ISO_FLOW_VERIFY_MSG_TYPE
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;
		IF (InputRoot.XMLNSC.data.flowType = 'P' OR InputRoot.XMLNSC.data.flowType = 'p') THEN
			IF STARTSWITH(InputRoot.XMLNSC.data.body.messageType, '020') THEN
				PROPAGATE TO TERMINAL 'out2';
			ELSEIF STARTSWITH(InputRoot.XMLNSC.data.body.messageType, '220') THEN
				IF InputRoot.XMLNSC.data.TimeOutCounter IS NOT NULL THEN
					SET OutputRoot.XMLNSC.data.TimeOutCounter = CAST(InputRoot.XMLNSC.data.TimeOutCounter AS INTEGER) + 1;
					RETURN TRUE;
				ELSE
					SET OutputRoot.XMLNSC.data.TimeOutCounter = 1;
					PROPAGATE TO TERMINAL 'out2';
				END IF;
			ELSE
				IF InputRoot.XMLNSC.data.TimeOutCounter IS NOT NULL THEN
					SET OutputRoot.XMLNSC.data.TimeOutCounter = CAST(InputRoot.XMLNSC.data.TimeOutCounter AS INTEGER) + 1;
				ELSE
					SET OutputRoot.XMLNSC.data.TimeOutCounter = 1;
				END IF;
				RETURN TRUE;
			END IF;
		ELSE
			PROPAGATE TO TERMINAL 'out1';
		END IF;
		RETURN FALSE;
	END;
END MODULE;


CREATE COMPUTE MODULE ISO_FLOW_SET_ERROR
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;
		IF STARTSWITH(InputRoot.XMLNSC.data.body.messageType, '022') THEN
			SET OutputRoot.XMLNSC.data.body.messageType = '0230';
		ELSEIF STARTSWITH(InputRoot.XMLNSC.data.body.messageType, '02') THEN
			SET OutputRoot.XMLNSC.data.body.messageType = MsgFinRespType;
		ELSEIF STARTSWITH(InputRoot.XMLNSC.data.body.messageType, '04') THEN
			SET OutputRoot.XMLNSC.data.body.messageType = MsgRevRespType;
		ELSE
			SET OutputRoot.XMLNSC.data.body.messageType = MsgNetRespType;
		END IF;
		SET OutputRoot.XMLNSC.data.body.{bit39} = '89';
		SET OutputRoot.XMLNSC.data.code = OutputRoot.XMLNSC.data.body.messageType||'.'||InputRoot.XMLNSC.data.body.{bit3};
		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;

CREATE COMPUTE MODULE ISO_FLOW_NET_MSG_FAILED
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET netStatus = 0;
		RETURN TRUE;
	END;
END MODULE;

CREATE COMPUTE MODULE ISO_FLOW_CHECK_NETMSG_RESP
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;
		IF InputRoot.XMLNSC.data.body.{bit70} = '201' THEN
			RETURN TRUE;
		--ELSEIF InputRoot.XMLNSC.data.body.{bit39} = '00' THEN
		--	PROPAGATE TO TERMINAL 'out1';
		END IF;	
		RETURN FALSE;
	END;
END MODULE;


CREATE COMPUTE MODULE ISO_FLOW_CHECK_RESP
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;
		IF InputRoot.XMLNSC.data.body.{bit39} = '00' AND InputRoot.XMLNSC.data.body.messageType = MsgFinRespType THEN
			PROPAGATE TO TERMINAL 'out1';
		END IF;
		RETURN TRUE;
	END;
END MODULE;

CREATE COMPUTE MODULE ISO_FLOW_CHECK_MSGTYPE
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;
		SET OutputRoot.XMLNSC.data.group = InputRoot.XMLNSC.data.request.data.body.frontOriginal.group;
		IF STARTSWITH(InputRoot.XMLNSC.data.body.messageType,'02') OR  STARTSWITH(InputRoot.XMLNSC.data.body.messageType,'04') THEN
			SET OutputRoot.XMLNSC.data.mappingId = InputRoot.XMLNSC.data.request.data.body.frontOriginal.group||'.'||
					InputRoot.XMLNSC.data.request.data.body.frontOriginal.code||'.'||
					InputRoot.XMLNSC.data.source||'.'||InputRoot.XMLNSC.data.code;
--			IF OutputRoot.XMLNSC.data.mappingId IS NULL THEN
--				SET OutputRoot.XMLNSC.data.mappingId = 'core-reverse.'||InputRoot.XMLNSC.data.code||'.'||InputRoot.XMLNSC.data.body.responseCode;
--			END IF;

			IF CONTAINS(InputRoot.XMLNSC.data.request.data.body.frontOriginal.codex, 'iso') THEN
				
			ELSE
				IF InputRoot.XMLNSC.data.body.responseCode = '00' THEN
					SET OutputRoot.XMLNSC.data.mappingId = OutputRoot.XMLNSC.data.mappingId||'.resp';
				ELSE
					SET OutputRoot.XMLNSC.data = InputRoot.XMLNSC.data.request.data.body.frontOriginal;
					SET OutputRoot.XMLNSC.data.mappingId = InputRoot.XMLNSC.data.request.data.body.frontOriginal.group||'.failed';
					--SET OutputRoot.XMLNSC.data.body.statusDescription = InputRoot.XMLNSC.data.body.
					SET OutputRoot.XMLNSC.data.billerCode=InputRoot.XMLNSC.data.source;
					SET OutputRoot.XMLNSC.data.body.responseCode = InputRoot.XMLNSC.data.body.responseCode;
				END IF;
			END IF;
			
			IF OutputRoot.XMLNSC.data.mappingId IS NULL THEN
				SET OutputRoot.XMLNSC.data.mappingId = 'core-reverse.'||InputRoot.XMLNSC.data.source||'.'||InputRoot.XMLNSC.data.code||'.'||SUBSTRING(InputRoot.XMLNSC.data.body.reservedPrivate2 FROM 1 FOR 3)||'.'||InputRoot.XMLNSC.data.body.responseCode;
				SET OutputRoot.XMLNSC.data.group = 'sms';
				PROPAGATE TO TERMINAL 'out2';
				RETURN FALSE;
			END IF;
			
			SET OutputRoot.MQMD.ReplyToQMgr = '';
			PROPAGATE TO TERMINAL 'out1';
			RETURN FALSE;
		ELSE
			RETURN TRUE;
		END IF;
	END;
END MODULE;

--CREATE COMPUTE MODULE ISO_FLOW_CHECK_MSGTYPE2
--	CREATE FUNCTION Main() RETURNS BOOLEAN
--	BEGIN
--		SET OutputRoot = InputRoot;
--		IF STARTSWITH(InputRoot.XMLNSC.data.body.messageType, '04') THEN
--			RETURN TRUE;
--		ELSE
--			PROPAGATE TO TERMINAL 'out1';
--		END IF;
--		RETURN FALSE;
--	END;
--
--	CREATE PROCEDURE CopyMessageHeaders() BEGIN
--		DECLARE I INTEGER 1;
--		DECLARE J INTEGER;
--		SET J = CARDINALITY(InputRoot.*[]);
--		WHILE I < J DO
--			SET OutputRoot.*[I] = InputRoot.*[I];
--			SET I = I + 1;
--		END WHILE;
--	END;
--
--	CREATE PROCEDURE CopyEntireMessage() BEGIN
--		SET OutputRoot = InputRoot;
--	END;
--END MODULE;



CREATE COMPUTE MODULE MASTER_ISO_FLOW_SAVE_REQMSG
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;
		SET OutputLocalEnvironment.data = InputRoot.XMLNSC.data;
		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;


CREATE COMPUTE MODULE MASTER_ISO_FLOW_SET_REPLY_TOQ
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;
		SET OutputRoot.XMLNSC.data.ReplyToQ = InputRoot.MQMD.ReplyToQ;
		RETURN TRUE;
	END;
END MODULE;

CREATE COMPUTE MODULE MASTER_ISO_FLOW_SET_TO
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;
		IF InputRoot.XMLNSC.data.body.frontOriginal.group IS NOT NULL THEN
			SET OutputRoot.XMLNSC.data = InputRoot.XMLNSC.data.body.frontOriginal;
		END IF;
		IF STARTSWITH(OutputRoot.XMLNSC.data.body.messageType, '022') THEN
			SET OutputRoot.XMLNSC.data.body.messageType = '0230';
		ELSEIF STARTSWITH(OutputRoot.XMLNSC.data.body.messageType, '02') THEN
			SET OutputRoot.XMLNSC.data.body.messageType = '0210';
		ELSEIF STARTSWITH(OutputRoot.XMLNSC.data.body.messageType, '04') THEN
			SET OutputRoot.XMLNSC.data.body.messageType = '0410';
		END IF;
		SET OutputRoot.XMLNSC.data.mappingId = 'resp-to.'||InputRoot.XMLNSC.data.body.frontOriginal.group;
		SET OutputRoot.XMLNSC.data.body.responseCode = '68';
		SET OutputRoot.MQMD.ReplyToQ = InputRoot.XMLNSC.data.ReplyToQ;
		SET OutputRoot.MQMD.ReplyToQMgr = '';
		RETURN TRUE;
	END;
END MODULE;

CREATE COMPUTE MODULE MASTER_ISO_FLOW_NO_MSG
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;
		SET OutputLocalEnvironment.MQMD = InputLocalEnvironment.MQMD;
		SET OutputRoot.XMLNSC.data = InputLocalEnvironment.data;
		RETURN TRUE;
	END;
END MODULE;
