BROKER SCHEMA subflow

CREATE COMPUTE MODULE TCPIP_ADAPTER_CHECK_MSSG_TYPE
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;
		-- IF STARTSWITH(InputRoot.XMLNSC.data.body.messageType, '02')
		-- OR STARTSWITH(InputRoot.XMLNSC.data.body.messageType, '04')
		-- OR STARTSWITH(InputRoot.XMLNSC.data.body.messageType, '2')THEN
		-- RETURN TRUE;
		-- ELSE
		-- IF STARTSWITH(InputRoot.XMLNSC.data.body.messageType, '08') AND STARTSWITH(InputRoot.XMLNSC.data.body.networkManagementInformationCode, '101') THEN
		-- RETURN TRUE;
		-- ELSE
		-- RETURN FALSE;
		-- END IF;
		-- END IF;
		IF SUBSTRING(InputRoot.XMLNSC.data.body.messageType FROM 2 FOR 1) = '8' AND NOT STARTSWITH(InputRoot.XMLNSC.data.body.networkManagementInformationCode, '101') THEN
			RETURN FALSE;
		ELSE
			RETURN TRUE;
		END IF;
	END;
END MODULE;


CREATE COMPUTE MODULE TCPIP_ADAPTER_CHECK_ERROR_MSG
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputLocalEnvironment = InputLocalEnvironment;
		IF InputRoot.XMLNSC.data.error = 'timeout' THEN
			IF STARTSWITH(InputRoot.XMLNSC.data.request.data.body.messageType, '08') THEN
				IF STARTSWITH(InputRoot.XMLNSC.data.request.data.body.messageType, '081') AND STARTSWITH(InputRoot.XMLNSC.data.request.data.body.networkManagementInformationCode, '001') THEN
					CALL CopyMessageHeaders();
					SET OutputRoot.XMLNSC.data = InputRoot.XMLNSC.data.request.data;
					SET OutputLocalEnvironment.Destination.RouterList.DestinationData[1].labelname = 'resignon';
					RETURN TRUE;
				END IF;
			ELSE
				CALL CopyMessageHeaders();
				SET OutputRoot.XMLNSC.data = InputRoot.XMLNSC.data.request.data;
				SET OutputRoot.XMLNSC.data.CorrelId = CAST(InputRoot.XMLNSC.data.body.frontOriginal.CorrelId AS BLOB CCSID 1208);
				SET OutputRoot.XMLNSC.data.billerSource = InputRoot.XMLNSC.data.request.data.destination;
				PROPAGATE TO TERMINAL 'out1';
				RETURN FALSE;
			END IF;
		END IF;
		RETURN FALSE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;


CREATE COMPUTE MODULE TCPIP_ADAPTER_CHECK_PASSTROUGH
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;
		IF STARTSWITH(InputRoot.XMLNSC.data.request.data.passtrough, 'true') THEN
			SET OutputRoot.XMLNSC.data = InputRoot.XMLNSC.data.request.data;
			SET OutputRoot.XMLNSC.data.raw = InputRoot.XMLNSC.data.raw;
			SET OutputRoot.XMLNSC.data.maskraw = InputRoot.XMLNSC.data.maskraw;
			SET OutputRoot.XMLNSC.data.body = InputRoot.XMLNSC.data.body;
			SET OutputRoot.XMLNSC.data.code = InputRoot.XMLNSC.data.code;
			PROPAGATE TO TERMINAL 'out1';
			RETURN FALSE;
		ELSEIF InputRoot.XMLNSC.data.request.data.destination IS NOT NULL THEN
			RETURN TRUE;
		ELSEIF InputRoot.XMLNSC.data.error IS NOT NULL THEN
			RETURN TRUE;
		ELSE
			PROPAGATE TO TERMINAL 'out2';
			RETURN FALSE;
		END IF;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;


CREATE COMPUTE MODULE TCPIP_ADAPTER_CHECK_TO_PASSTROUGH
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;
		IF STARTSWITH(InputRoot.XMLNSC.data.request.data.passtrough, 'true') THEN
			SET OutputRoot.XMLNSC.data.body.{bit39} = '68';
			SET OutputRoot.MQMD.ReplyToQ = InputLocalEnvironment.replyToQ;
			SET OutputRoot.MQMD.ReplyToQMgr = InputLocalEnvironment.replyToQMgr;
			PROPAGATE TO TERMINAL 'out1';
			RETURN FALSE;
		ELSE
			PROPAGATE TO TERMINAL 'out2';
			RETURN FALSE;
		END IF;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;


CREATE COMPUTE MODULE TCPIP_ADAPTER_CHECK_PASSTROUGH_FAIL
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;

		IF STARTSWITH(InputRoot.XMLNSC.data.request.data.passtrough,'true') THEN
			SET OutputRoot.XMLNSC.data=InputRoot.XMLNSC.data.body.frontOriginal;
			SET OutputRoot.XMLNSC.data.body.{bit39} = respLinkDown;
			SET OutputRoot.XMLNSC.data.body.messageType=SUBSTRING(InputRoot.XMLNSC.data.body.messageType FROM 1 FOR 2)||'10';

			PROPAGATE TO TERMINAL 'out1';
			RETURN FALSE;
		ELSE
			IF STARTSWITH(InputRoot.XMLNSC.data.error,'not signed') THEN
				SET OutputLocalEnvironment.Destination.RouterList.DestinationData[1].labelname = 'resignon';
				PROPAGATE TO TERMINAL 'out2';
			END IF;

			SET OutputRoot = InputRoot;
			SET OutputRoot.XMLNSC.data = InputLocalEnvironment.data;
			RETURN TRUE;
		END IF;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;


CREATE COMPUTE MODULE TCPIP_ADAPTER_SAVE_REPLYTO_Q
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;
		IF InputLocalEnvironment.data IS NOT NULL AND InputRoot.XMLNSC.data.body.frontOriginal IS NOT NULL THEN
			SET OutputRoot.XMLNSC.data.body.frontOriginal = InputLocalEnvironment.data;
		END IF;
		SET OutputRoot.XMLNSC.data.ReplyToQ = InputRoot.MQMD.ReplyToQ;
		SET OutputRoot.XMLNSC.data.ReplyToQMgr = InputRoot.MQMD.ReplyToQMgr;
		SET OutputLocalEnvironment.data = OutputRoot.XMLNSC.data;
		SET OutputRoot.XMLNSC.data.sid = NULL;
		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;


CREATE COMPUTE MODULE TCPIP_ADAPTER_CHECK_MSGTYPE1
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;
		SET OutputLocalEnvironment = InputLocalEnvironment;
		IF STARTSWITH(InputRoot.XMLNSC.data.body.messageType,'08') THEN
			IF STARTSWITH(InputRoot.XMLNSC.data.body.messageType,'0810') THEN
				IF InputRoot.XMLNSC.data.body.{bit70} = '001' THEN
					IF InputRoot.XMLNSC.data.body.responseCode = '00' THEN
						SET OutputRoot.XMLNSC.data.control = 'sign on';
						PROPAGATE TO TERMINAL 'out1';
					ELSE
						SET OutputLocalEnvironment.Destination.RouterList.DestinationData[1].labelname = 'resignon';
						PROPAGATE TO TERMINAL 'out2';
					END IF;
				ELSEIF InputRoot.XMLNSC.data.body.{bit70} = '002' THEN
					IF InputRoot.XMLNSC.data.body.responseCode = '00' THEN
						SET OutputRoot.XMLNSC.data.control = 'sign off';
						PROPAGATE TO TERMINAL 'out1';
					END IF;
				ELSEIF InputRoot.XMLNSC.data.body.networkManagementInformationCode='101' THEN
					--IF InputRoot.XMLNSC.data.body.responseCode = '00' THEN
					SET OutputRoot.XMLNSC.data.CorrelId = InputLocalEnvironment.CorrelId;
					SET OutputRoot.XMLNSC.data.reqtimestamp = InputRoot.XMLNSC.data.request.data.reqtimestamp;
					PROPAGATE TO TERMINAL 'out';
					--END IF;
					--RETURN TRUE;
				END IF;
			ELSE
				SET OutputRoot.XMLNSC.data.destination = InputRoot.XMLNSC.data.source;
				SET OutputRoot.XMLNSC.data.nosignon = 'true';
				SET OutputRoot.XMLNSC.data.body.messageType = '0810';
				SET OutputRoot.XMLNSC.data.body.responseCode = '00';
				SET OutputLocalEnvironment.Destination.RouterList.DestinationData[1].labelname = 'netManReply';
				PROPAGATE TO TERMINAL 'out2';
			END IF;
			RETURN FALSE;
		ELSE
			SET OutputRoot.XMLNSC.data.CorrelId = InputLocalEnvironment.CorrelId;
			IF InputRoot.XMLNSC.data.request.data.reqtimestamp IS NOT NULL THEN
				SET OutputRoot.XMLNSC.data.reqtimestamp = InputRoot.XMLNSC.data.request.data.reqtimestamp;
			ELSE
				SET OutputRoot.XMLNSC.data.reqtimestamp = InputRoot.XMLNSC.data.timestamp;
			END IF;
			IF InputRoot.XMLNSC.data.request.data.ReplyToQ IS NULL THEN
				SET OutputRoot.XMLNSC.data.request.data.ReplyToQ = 'ROUTER_OUT';
			END IF;
			RETURN TRUE;
		END IF;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;



CREATE COMPUTE MODULE TCPIP_ADAPTER_CHECK_TYPE
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;
		IF InputRoot.XMLNSC.data.control = 'echo' THEN
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		END IF;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;


CREATE COMPUTE MODULE TCPIP_ADAPTER_CHECK_DESTINATION
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputRoot = InputRoot;
		IF InputRoot.XMLNSC.data.destination IS NOT NULL THEN
			RETURN TRUE;
		ELSE
			PROPAGATE TO TERMINAL 'out1';
			RETURN FALSE;
		END IF;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;